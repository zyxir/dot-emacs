# -*- org-edit-src-content-indentation: 0; -*-
#+TITLE: Zyxir's Emacs Configuration
#+STARTUP: content

* Introduction

** Todos

- [ ] Gradually replace everything with ~use-package~ for better startup performance.
- [ ] Replace auctex with a LaTeX language server.
- [ ] Use LSP as a company backend.
- [ ] Use org-sidebar for easier org-mode navigation.
- [ ] Integrate window numbering to the system.
- [X] Rename all "my" symbol names with "zy".

** Installation Steps

These steps is **for myself only**. You may adapt my config, but it is never
recommended to use it directly.

1. Init and update all submodules.
2. Make sure ~msys2~ or ~mingw~ is installed on Windows, as a C compiler is
   required to compile some functionalities.
3. Write own =custom.el= based on =example-custom.el=. Make sure your configured
   font is installed on your system.
4. On Windows, add =./3rd-party/im-select/im-select.exe= to path, to enable
  smart input source support.
5. Run =M-x all-the-icons-install-fonts= for icon support.
6. Other small functionalities:
   - Install ~opencc~ for Chinese conversion support.

** (Chinese) 配置介紹

這是我的 Emacs 配置。我主要使用 Emacs 來進行個人知識管理、待辦事項管理、簡單文檔
撰寫、輕度代碼編輯。

高手的配置通常是以代碼項目的形式管理的（例如 Purcell 的配置，Doom Emacs，Centuar
Emacs 等等）。但對我個人而言，我更喜歡方便編輯與查看的 literate programming 形式。
我的配置的每一行代碼，都是以 source block 的形式存放在這個 org 文件中的，而標準
配置文件 ~init.el~ 的作用，就是讀取與執行本 org 文件中的每塊 source block。使用
這種配置方法的人也有很多，而其中最知名的應該就是 Sacha Chua 了。

明明有 Evernote、Notion 等用戶體驗良好的商用工具，爲什么還要將 Emacs 用於個人知
識管理、文檔撰寫等用途？事實上，我本人非常喜歡 Notion，並且曾經用了它很長時間；
那麼使用 Emacs 而不用 Notion 的原因，我想可以用 Carsten Dominik 於 2008 年在
Google Tech Talks 上講的一段話來概括：

#+begin_quote
“Text files are the only truly portable format for files, so we can write things
down and read it anywhere, read it on a small device, read it on a big device,
on any computer, Linux, Windows, on a Macintosh, whatever. You can read it truly
anywhere, that data will never get lost. So, 20 years from now, you will still
be able to read these files, which you wrote.”。
#+end_quote

* Emacs Configuration

The configuration is divided into these categories:

- General :: General software-wide configuration.
- Information :: Gathering information about the system, the user,
  etc..
- Text Editor :: Settings about text editing.
- Workbench :: Visual UI settings.
- Window :: Settings about windows and frames.
- Feature :: Specific features like version control and project
  management.
- Extensions :: Settings for specific file name extensions, like
  ~.py~.

** General

*** Garbage Collection Threshold

Make startup faster by reducing the frequency of garbage collection. The
default is 800 kilobytes, which is too low for modern machines.

#+begin_src emacs-lisp
(let ((normal-gc-cons-threshold (* 20 1024 1024))
      (init-gc-cons-threshold (* 128 1024 1024)))
  (setq gc-cons-threshold init-gc-cons-threshold)
  (add-hook 'emacs-startup-hook
	    (lambda ()
	      (setq gc-cons-threshold normal-gc-cons-threshold))))
#+end_src

*** Package Manager

Install ~use-package~, and manage package with it from now on.

#+begin_src emacs-lisp
(require 'package)
(setq package-archives
      '(("melpa" . "http://mirrors.ustc.edu.cn/elpa/melpa/")
	("org"   . "http://mirrors.ustc.edu.cn/elpa/org/"))
      package-archive-priorities
      '(("melpa" . 10)
	("org" . 20)))
(package-install 'use-package)
(eval-when-compile
  (require 'use-package))
;; Always install missing packages.
(setq use-package-always-ensure t)
#+end_src

*** Date and Time Format

Use ISO C date format everywhere.

#+begin_src emacs-lisp
(setq system-time-locale "C")
#+end_src

*** Command Completion

Use the simple ivy, and extend some commands with counsel.

#+begin_src emacs-lisp
(use-package ivy
  :diminish
  :config
  (ivy-mode)
  ;; Add recent files/bookmarks to ivy-switch-buffer.
  (setq ivy-use-virtual-buffers t)
  ;; Enable minibuffer inside minibuffer.
  (setq enable-recursive-minibuffers t))

(use-package counsel
  :diminish
  :config
  (counsel-mode))
#+end_src

*** Key Binding

Use ~general.el~ for key bindings.

#+begin_src emacs-lisp
(use-package general)
#+end_src

*** Bug Fix

Hide this kind of warning:

#+begin_quote
ad-handle-definition: 'text-scale-increase' got redefined.
#+end_quote

#+begin_src emacs-lisp
(setq ad-redefinition-action 'accept)
#+end_src

** Information

*** Personal Information

Information about the user.

#+begin_src emacs-lisp
(setq user-full-name "Eric Zhuo Chen"
      user-mail-address "zyxirchen@outlook.com")
#+end_src

*** File Locations

The location of several important files and directories. Note that the
location of Zybox is left empty here.

#+begin_src emacs-lisp
(defvar zy/emacs-config-file nil
  "The main Emacs configuration file.")
(setq zy/emacs-config-file (concat user-emacs-directory
				   "README.org"))

(defvar zy/3rd-party-relapath nil
  "The path of 3rd-party tools relative to the user Emacs directory.")
(setq zy/3rd-party-relapath "3rd-party/")

(defvar zy/zybox-path nil
  "The path of Zybox, the base of all my files.")

(defvar zy/projects-relapath nil
  "The path of the projects directory relative to Zybox.")
(setq zy/projects-relapath "projects/")

(defvar zy/std-proj-relapath nil
  "The path of my Project Standard specification file, relative to Zybox.")
(setq zy/std-proj-relapath "projects/ego/std/std-proj/README.org")
#+end_src

These locations varies across my devices, so Emacs should reads an external
file named ~custom.el~, to get the accurate location. The location of Zybox
should be set there. If no Zybox location is assigned, an error would be
signaled.

#+begin_src emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))
(if (file-exists-p custom-file)
    (load custom-file))
(when (equal zy/zybox-path nil)
  (error "No Zybox path is assigned!"))
#+end_src

Construct absolute paths and other file locations.

#+begin_src emacs-lisp
;; Fix `zy/zybox-path` if it is incorrect.
(setq zy/zybox-path (file-name-as-directory zy/zybox-path))

(defvar zy/3rd-party-path nil
  "The path of 3rd-party tools.")
(setq zy/3rd-party-path (concat user-emacs-directory zy/3rd-party-relapath))

(defvar zy/projects-path nil
  "The path of the projects directory.")
(setq zy/projects-path (concat zy/zybox-path zy/projects-relapath))

(defvar zy/std-proj-path nil
  "The path of my Project Standard specification file.")
(setq zy/std-proj-path (concat zy/zybox-path zy/std-proj-relapath))
#+end_src

** Text Editor

*** Code Completion

Install company completion framework. Manually complete with =C-M-i=, which is
originally ~complete-at-point~. In some modes, like matlab-mode, this key would
be overwritten.

#+begin_src emacs-lisp
(use-package company
  :hook
  (prog-mode .
	     (lambda ()
	       (company-mode 1)
	       (general-define-key
		:keymaps 'local
		"C-M-i" 'company-complete)))
  :diminish)
#+end_src

*** Camel Case Editing

Make Emacs aware of camel case.

#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :config
  (add-hook 'prog-mode-hook 'subword-mode))
#+end_src

*** Encoding

I used to set everything to UTF-8 simply by ~set-language-environment~, but that
broke things on Windows, especially on the Chinese version, as is described in
[[https://github.com/hick/emacs-chinese#ms-windows-%E7%8E%AF%E5%A2%83%E7%9A%84-utf-8-%E9%85%8D%E7%BD%AE][this page]]:

#+CAPTION: Windows 下 UTF-8 是「二等公民」
[[file:images/emacs-chinese-utf-8-side-effects.png]]

Now I configure things like this:

#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :config
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8)
  (set-buffer-file-coding-system 'utf-8-unix)
  (set-clipboard-coding-system 'utf-8-unix)
  (set-file-name-coding-system 'utf-8-unix)
  (set-keyboard-coding-system 'utf-8-unix)
  (set-next-selection-coding-system 'utf-8-unix)
  (if (eq system-type 'windows-nt)
      (progn
	(set-selection-coding-system 'utf-16le-dos)
	(set-default 'process-coding-system-alist
		     '(("[pP][lL][iI][nN][kK]" gbk-dos . gbk-dos)
		       ("[cC][mM][dD][pP][rR][oO][xX][yY]" gbk-dos . gbk-dos))))
    (set-selection-coding-system 'utf-8-unix))
  (set-terminal-coding-system 'utf-8-unix)
  (setq locale-coding-system 'utf-8)
  (prefer-coding-system 'utf-8))
#+end_src

*** Buffers and Files

**** Cursor Position

Always save cursor position.

#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :config
  (save-place-mode 1))
#+end_src

**** Backup

A better backup and auto save configuration.

#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :config
  (defvar zy/backup-directory nil
    "The location of backups.")
  (setq zy/backup-directory
	(concat user-emacs-directory
		"backups"))

  (unless (file-exists-p zy/backup-directory)
    (make-directory zy/backup-directory t))
  (setq backup-directory-alist `(("." . ,zy/backup-directory)))
  (setq make-backup-files t
	vc-make-backup-files t
	backup-by-copying t
	version-control t
	delete-old-versions t
	delete-by-moving-to-trash t
	kept-old-versions 0
	kept-new-versions 10
	auto-save-default t
	auto-save-timeout 20
	auto-save-interval 200))
#+end_src

**** File Manipulation

Load some handy file manipulation functions from a library file.

#+begin_src emacs-lisp
(use-package zy-file-utils
  :load-path "site-lisp/zy-file-utils/")
#+end_src

**** Recent Files

Make use of =recentf.el=.

#+begin_src emacs-lisp
(use-package recentf
  :ensure nil
  :general
  ("C-x r" 'counsel-recentf)
  :config
  ;; Tweak it.
  (setq recentf-max-saved-items 200
	recentf-max-menu-items 15)
  (recentf-mode 1))
#+end_src

*** Format

Show trailing whitespace for most modes.

#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :general
  ("C-c SPC" 'delete-trailing-whitespace)
  :config
  (defun zy/show-trailing-whitespace ()
    "Turn on whitespace mode for the current buffer."
    (setq-local show-trailing-whitespace t))
  (add-hook 'prog-mode-hook 'zy/show-trailing-whitespace)
  (add-hook 'text-mode-hook 'zy/show-trailing-whitespace)

  (add-hook 'before-save-hook 'delete-trailing-whitespace))
#+end_src

Set default fill column to 79.

#+begin_src emacs-lisp
(setq-default fill-column 79)
#+end_src

*** Input Method

Use ~sis~ (smart input source) to reduce manual switch for OS input source.

#+begin_src emacs-lisp
(use-package sis
  :config
  (sis-global-respect-mode t))
#+end_src

**Platform-specific settings should be configured in custom.el** in accordance
to the README of ~sis~.

*** Location

Show side line numbers and column number while coding.

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook
	  (lambda ()
	    (display-line-numbers-mode 1)))
(column-number-mode 1)
#+end_src

*** Parenthesis

Indicate matching parenthesis.

#+begin_src emacs-lisp
(show-paren-mode 1)
#+end_src

*** Project Management

Manage projects with projectile, and use =C-x p= as the shortcut.

#+begin_src emacs-lisp
(use-package projectile
  :diminish
  :general
  (:keymaps 'ctl-x-map
   "p" 'projectile-command-map)
  :config
  (projectile-mode t))
#+end_src

**** Search Path

Default search for projects in the user defined projects path.

#+begin_src emacs-lisp
(setq projectile-project-search-path `(,zy/projects-path))
#+end_src

*** Search

Replace isearch with swiper.

#+begin_src emacs-lisp
(use-package swiper
  :general
  ("C-s" 'swiper)
  :config
  ;; Enable character folding (having =bar= matching =bár=) for swiper.
  (setq search-default-mode #'char-fold-to-regexp))
#+end_src

*** Syntax Checking

Use flycheck for syntax checking.

#+begin_src emacs-lisp
(use-package flycheck)
#+end_src

Enable flycheck-mode for each language specifically.

** Workbench

*** Startup

Inhibit startup screen.

#+begin_src emacs-lisp
(setq inhibit-startup-screen t)
#+end_src

*** Icon

Add icon support.

#+begin_src emacs-lisp
(use-package all-the-icons)
#+end_src

*** Appearances

Font and color theme.

#+begin_src emacs-lisp
(defvar zy/main-font-name nil
  "Main font name for the whole program.")
(setq zy/main-font-name "Sarasa Mono CL")

(defvar zy/main-font-size nil
  "The default size for the main font.")
(setq zy/main-font-size 11)

(setq zy/main-font-full (concat zy/main-font-name " "
			     (number-to-string zy/main-font-size)))

(when (display-graphic-p)
  (set-face-attribute 'default nil :font zy/main-font-full)
  (set-frame-font zy/main-font-full)
  (dolist (charset '(kana han symbol cjk-misc bopomofo))
    (set-fontset-font (frame-parameter nil 'font) charset
		      (font-spec :family zy/main-font-name))))

(use-package doom-themes
  :if window-system
  :config
  (load-theme 'doom-one-light t))

(use-package solaire-mode
  :if window-system
  :config
  (solaire-global-mode t))
#+end_src

Disable unnecessary UI elements.

#+begin_src emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
#+end_src

Add a vertical line indicating the fill-column for all programming modes.

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook
	  (lambda ()
	    (display-fill-column-indicator-mode t)))
#+end_src

*** Treemacs

Treemacs is a great feature for IDE-like experience.

#+begin_src emacs-lisp
(use-package treemacs
  :general
  ("M-0" 'treemacs-select-window)
  :config
  ;; Use doom theme.
  (setq doom-theme-treemacs-theme "doom-colors"
	doom-theme-treemacs-enable-variable-pitch nil)
  (doom-themes-treemacs-config))

(use-package treemacs-projectile
  :after treemacs)
#+end_src

*** Which-key

Which-key displays the key bindings following your currently entered
incomplete command (a prefix) in a popup.

#+begin_src emacs-lisp
(use-package which-key
  :diminish
  :config
  ;; Popup side window on bottom.
  (which-key-setup-side-window-bottom)
  ;; Show which-key on C-h.
  (setq which-key-show-early-on-C-h t))
#+end_src

** Window

*** Frame Behavior

If running with GUI, adjust the frame.

#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :if window-system
  :config
  (setq initial-frame-alist
	'((width . 110)
	  (height . 40)))
  (setq default-frame-alist initial-frame-alist))
#+end_src

** Extensions

*** CMake Files

#+begin_src emacs-lisp
(use-package cmake-mode)
#+end_src

*** Emacs Lisp

Diminish eldoc-mode.

#+begin_src emacs-lisp
(use-package eldoc
  :ensure nil
  :diminish)
#+end_src

**** Indent Behavior Modification

Stop Emacs from indenting quoted and unquoted lists as functions. See [[https://emacs.stackexchange.com/a/52789][this
StackExchange answer]] for more information.

#+begin_src emacs-lisp
(defun void~calculate-lisp-indent (&optional parse-start)
  "Add better indentation for quoted and backquoted lists."
  ;; This line because `calculate-lisp-indent-last-sexp` was defined with `defvar`
  ;; with it's value ommited, marking it special and only defining it locally. So
  ;; if you don't have this, you'll get a void variable error.
  (defvar calculate-lisp-indent-last-sexp)
  (save-excursion
    (beginning-of-line)
    (let ((indent-point (point))
          state
          ;; setting this to a number inhibits calling hook
          (desired-indent nil)
          (retry t)
          calculate-lisp-indent-last-sexp containing-sexp)
      (cond ((or (markerp parse-start) (integerp parse-start))
             (goto-char parse-start))
            ((null parse-start) (beginning-of-defun))
            (t (setq state parse-start)))
      (unless state
        ;; Find outermost containing sexp
        (while (< (point) indent-point)
          (setq state (parse-partial-sexp (point) indent-point 0))))
      ;; Find innermost containing sexp
      (while (and retry
                  state
                  (> (elt state 0) 0))
        (setq retry nil)
        (setq calculate-lisp-indent-last-sexp (elt state 2))
        (setq containing-sexp (elt state 1))
        ;; Position following last unclosed open.
        (goto-char (1+ containing-sexp))
        ;; Is there a complete sexp since then?
        (if (and calculate-lisp-indent-last-sexp
                 (> calculate-lisp-indent-last-sexp (point)))
            ;; Yes, but is there a containing sexp after that?
            (let ((peek (parse-partial-sexp calculate-lisp-indent-last-sexp
                                            indent-point 0)))
              (if (setq retry (car (cdr peek))) (setq state peek)))))
      (if retry
          nil
        ;; Innermost containing sexp found
        (goto-char (1+ containing-sexp))
        (if (not calculate-lisp-indent-last-sexp)
            ;; indent-point immediately follows open paren.
            ;; Don't call hook.
            (setq desired-indent (current-column))
          ;; Find the start of first element of containing sexp.
          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
          (cond ((looking-at "\\s(")
                 ;; First element of containing sexp is a list.
                 ;; Indent under that list.
                 )
                ((> (save-excursion (forward-line 1) (point))
                    calculate-lisp-indent-last-sexp)
                 ;; This is the first line to start within the containing sexp.
                 ;; It's almost certainly a function call.
                 (if (or
                      ;; Containing sexp has nothing before this line
                      ;; except the first element. Indent under that element.
                      (= (point) calculate-lisp-indent-last-sexp)

                      ;; First sexp after `containing-sexp' is a keyword. This
                      ;; condition is more debatable. It's so that I can have
                      ;; unquoted plists in macros. It assumes that you won't
                      ;; make a function whose name is a keyword.
                      ;; (when-let (char-after (char-after (1+ containing-sexp)))
                      ;;   (char-equal char-after ?:))

                      ;; Check for quotes or backquotes around.
                      (let* ((positions (elt state 9))
                             (last (car (last positions)))
                             (rest (reverse (butlast positions)))
                             (any-quoted-p nil)
                             (point nil))
                        (or
                         (when-let (char (char-before last))
                           (or (char-equal char ?')
                               (char-equal char ?`)))
                         (progn
                           (while (and rest (not any-quoted-p))
                             (setq point (pop rest))
                             (setq any-quoted-p
                                   (or
                                    (when-let (char (char-before point))
                                      (or (char-equal char ?')
                                          (char-equal char ?`)))
                                    (save-excursion
                                      (goto-char (1+ point))
                                      (looking-at-p
                                       "\\(?:back\\)?quote[\t\n\f\s]+(")))))
                           any-quoted-p))
			(when-let (char-after (char-after (1+ containing-sexp)))
			  (char-equal char-after ?:))
			))
                     ;; Containing sexp has nothing before this line
                     ;; except the first element.  Indent under that element.
                     nil
                   ;; Skip the first element, find start of second (the first
                   ;; argument of the function call) and indent under.
                   (progn (forward-sexp 1)
                          (parse-partial-sexp (point)
                                              calculate-lisp-indent-last-sexp
                                              0 t)))
                 (backward-prefix-chars))
                (t
                 ;; Indent beneath first sexp on same line as
                 ;; `calculate-lisp-indent-last-sexp'.  Again, it's
                 ;; almost certainly a function call.
                 (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point) calculate-lisp-indent-last-sexp
                                     0 t)
                 (backward-prefix-chars)))))
      ;; Point is at the point to indent under unless we are inside a string.
      ;; Call indentation hook except when overridden by lisp-indent-offset
      ;; or if the desired indentation has already been computed.
      (let ((normal-indent (current-column)))
        (cond ((elt state 3)
               ;; Inside a string, don't change indentation.
               nil)
              ((and (integerp lisp-indent-offset) containing-sexp)
               ;; Indent by constant offset
               (goto-char containing-sexp)
               (+ (current-column) lisp-indent-offset))
              ;; in this case calculate-lisp-indent-last-sexp is not nil
              (calculate-lisp-indent-last-sexp
               (or
                ;; try to align the parameters of a known function
                (and lisp-indent-function
                     (not retry)
                     (funcall lisp-indent-function indent-point state))
                ;; If the function has no special alignment
                ;; or it does not apply to this argument,
                ;; try to align a constant-symbol under the last
                ;; preceding constant symbol, if there is such one of
                ;; the last 2 preceding symbols, in the previous
                ;; uncommented line.
                (and (save-excursion
                       (goto-char indent-point)
                       (skip-chars-forward " \t")
                       (looking-at ":"))
                     ;; The last sexp may not be at the indentation
                     ;; where it begins, so find that one, instead.
                     (save-excursion
                       (goto-char calculate-lisp-indent-last-sexp)
                       ;; Handle prefix characters and whitespace
                       ;; following an open paren.  (Bug#1012)
                       (backward-prefix-chars)
                       (while (not (or (looking-back "^[ \t]*\\|([ \t]+"
                                                     (line-beginning-position))
                                       (and containing-sexp
                                            (>= (1+ containing-sexp) (point)))))
                         (forward-sexp -1)
                         (backward-prefix-chars))
                       (setq calculate-lisp-indent-last-sexp (point)))
                     (> calculate-lisp-indent-last-sexp
                        (save-excursion
                          (goto-char (1+ containing-sexp))
                          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
                          (point)))
                     (let ((parse-sexp-ignore-comments t)
                           indent)
                       (goto-char calculate-lisp-indent-last-sexp)
                       (or (and (looking-at ":")
                                (setq indent (current-column)))
                           (and (< (line-beginning-position)
                                   (prog2 (backward-sexp) (point)))
                                (looking-at ":")
                                (setq indent (current-column))))
                       indent))
                ;; another symbols or constants not preceded by a constant
                ;; as defined above.
                normal-indent))
              ;; in this case calculate-lisp-indent-last-sexp is nil
              (desired-indent)
              (t
               normal-indent))))))

(advice-add #'calculate-lisp-indent
	    :override
	    #'void~calculate-lisp-indent)
#+end_src

*** LaTeX ~.tex~

*** MATLAB ~.m~

The old but useful MATLAB mode.

#+begin_src emacs-lisp
(use-package matlab
  :ensure matlab-mode
  :config
  ;; Treat .m files as MATLAB files.
  (add-to-list
   'auto-mode-alist
   '("\\.m\\'" . matlab-mode))
  (add-hook 'matlab-mode-hook
	    (lambda ()
	      (auto-fill-mode t)
	      (display-line-numbers-mode t))))
#+end_src

*** Org ~.org~

#+begin_src emacs-lisp
(use-package org
  :general
  ("C-c C-i" nil
   "C-c c" 'org-capture)
  :config
  ;; Do not adapt indentation.
  (setq-default org-adapt-indentation nil)
  ;; Add a new template for Emacs Lisp source blocks.
  (add-to-list 'org-structure-template-alist
	       '(";" . "src emacs-lisp"))
  ;; Hook.
  (add-hook 'org-mode-hook
	    (lambda ()
	      ;; Enable auto-fill.
	      (auto-fill-mode +1))))
#+end_src

**** Chinese Fix

Allow Chinese around markups. This comes from [[https://emacs-china.org/t/org-mode/597/4][Emacs China : Org-mode 中文行内格
式化的问题]], may not be stable.

#+begin_src emacs-lisp
(use-package org
  :init
  (setq org-emphasis-regexp-components
	;; markup 记号前后允许中文
	(list (concat " \t('\"{"            "[:nonascii:]")
	      (concat "- \t.,:!?;'\")}\\["  "[:nonascii:]")
	      " \t\r\n,\"'"
	      "."
	      1)))
#+end_src

**** Attachments

Put attachments in an obvious directory.

#+begin_src emacs-lisp
(setq org-attach-id-dir "org-attachments/")
#+end_src

**** Bullets

Show org-mode bullets as UTF-8 characters.

#+begin_src emacs-lisp
(use-package org-bullets
  :requires org-bullets
  :hook (org-mode . org-bullets-mode)
  :config
  ;; Render bullets ("•" and "◦") instead of dashes in bulleted lists.
  (font-lock-add-keywords 'org-mode
			  '(("^ *\\([-]\\) "
			     (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
  (font-lock-add-keywords 'org-mode
			  '(("^ *\\([+]\\) "
			     (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "◦"))))))
  (font-lock-add-keywords 'org-journal-mode
			  '(("^ *\\([-]\\) "
			     (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
  (font-lock-add-keywords 'org-journal-mode
			  '(("^ *\\([+]\\) "
			     (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "◦")))))))
#+end_src

**** Export to HTML

These code are copied from zwz's blog and only works for org-mode 8.0 or
higher. They are used to: 清除中文導出 HTML 後產生的多餘空格.

#+begin_src emacs-lisp
(defun clear-single-linebreak-in-cjk-string (string)
  "clear single line-break between cjk characters that is usually soft line-breaks"
  (let* ((regexp "\\([\u4E00-\u9FA5]\\)\n\\([\u4E00-\u9FA5]\\)")
	 (start (string-match regexp string)))
    (while start
      (setq string (replace-match "\\1\\2" nil nil string)
	    start (string-match regexp string start))))
  string)

(require 'ox-man)

(defun ox-html-clear-single-linebreak-for-cjk (string backend info)
  (when (org-export-derived-backend-p backend 'html)
    (clear-single-linebreak-in-cjk-string string)))

(add-to-list 'org-export-filter-final-output-functions
	     'ox-html-clear-single-linebreak-for-cjk)
#+end_src

**** Export to LaTeX

LaTeX exporting with Chinese in Emacs is always a pain. I am going to make it no
longer a pain.

***** 正確導出的方法

就目前而言，衹需要加入一個選項就可以正常導出中文文章：

#+begin_quote
#+LATEX_HEADER: \usepackage{ctex}
#+end_quote

其它細致選項，還需要具體地去針對各個文件來調整，例如使用 ~tags:nil~ 選項來去掉輸
出文件中的標籤。

***** 細調中文文檔類 cn-article

弄出一系列還不錯的預設選項，集成到 cn-article 類中，讓日後的文檔輸出更方便。

#+begin_src emacs-lisp
(add-to-list 'org-latex-classes
	     '("cn-article"
	       "\\documentclass[lang=cn]{elegantpaper}
\\usepackage{ctex}"
	       ("\\section{%s}" . "\\section*{%s}")
	       ("\\subsection{%s}" . "\\subsection*{%s}")
	       ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
	       ("\\paragraph{%s}" . "\\paragraph*{%s}")
	       ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+end_src

*** PlantUML

Install =plantuml-mode=, and use executable inside the 3rd-party directory.

#+begin_src emacs-lisp
(use-package plantuml-mode
  :config
  (setq plantuml-jar-path (concat zy/3rd-party-path "plantuml/plantuml.jar")
	plantuml-default-exec-mode 'jar))
#+end_src

*** Python ~.py~

Enable lsp mode for python, with pyright as the server.

#+begin_src emacs-lisp
(use-package lsp-pyright
  :after lsp
  :hook
  (python-mode .
	       (lambda ()
		 (require 'lsp-pyright)
		 (lsp))))
#+end_src

** Feature

*** Calendar and Org-Journal

I seldom use the built-in calendar of Emacs. But org-journal is great tool for
keeping daily journals, and calendar is essential to work with it.

#+begin_src emacs-lisp
(use-package calendar
  :ensure nil
  :general
  ("C-c g" 'calendar))

(use-package org-journal
  :general
  ("C-c j" 'org-journal-new-entry)
  :config
  (setq org-journal-dir (concat zy/zybox-path "org-journal"))
  (unless (file-exists-p org-journal-dir)
    (make-directory org-journal-dir))
  ;; Configure the template.
  (setq org-journal-file-format "%F"
	org-journal-date-format "%F %a W%V\n"
	org-journal-date-prefix "#+TITLE: "
	org-journal-time-format "%R "
	org-journal-time-format-post-midnight "%R (midnight) "
	org-journal-time-prefix "\n* "
	org-journal-file-header "")
  ;; If it is early than 3 a.m., it is still yesterday.
  (setq org-extend-today-until 3))
#+end_src

*** Chinese Conversion

Conversion between simplified/traditional Chinese with =opencc.el=. 使用
=opencc.el=進行中文簡繁轉換。

#+begin_src emacs-lisp
(use-package opencc
  :load-path "site-lisp/opencc/")
#+end_src

=opencc.el= is based on OpenCC:

#+begin_quote
Open Chinese Convert (OpenCC, 開放中文轉換) is an opensource project for
conversions between Traditional Chinese, Simplified Chinese and Japanese Kanji
(Shinjitai). It supports character-level and phrase-level conversion, character
variant conversion and regional idioms among Mainland China, Taiwan and Hong
Kong. This is not translation tool between Mandarin and Cantonese, etc.
#+end_quote

在 Windows 下，需要一些特殊的措施來使 OpenCC 得以正常運行。詳見[[file:documents/opencc-windows-conf.org][在 Windows 下使用 opencc.el]]。

*** Emojis

Install emojify to display emojis.

#+begin_src emacs-lisp
(use-package emojify
  :general
  ("C-c e" 'emojify-insert-emoji)
  :config
  (setq emojify-emoji-styles '(github))
  (global-emojify-mode +1))
#+end_src

*** Git

Magit is a complete text-based user interface to Git.

#+begin_src emacs-lisp
(use-package magit)
(use-package treemacs-magit
  :after (magit treemacs))
#+end_src

*** GTD

The aim is to implement a GTD system with org-mode.

**** Relevant Files

Define those relevant files.

#+begin_src emacs-lisp
(defvar zy/gtd-path nil
  "The path of my GTD system root.")

(defvar zy/gtd-inbox-path nil
  "The path of `inbox.org' of my GTD system.")

(defvar zy/gtd-gtd-path nil
  "The path of `gtd.org' of my GTD system.")

(defvar zy/gtd-someday-path nil
  "The path of `someday.org' of my GTD system.")

(setq zy/gtd-path
      (concat zy/zybox-path "org-gtd/")
      zy/gtd-inbox-path
      (concat zy/gtd-path "inbox.org")
      zy/gtd-gtd-path
      (concat zy/gtd-path "gtd.org")
      zy/gtd-someday-path
      (concat zy/gtd-path "someday.org"))
#+end_src

**** Todo States

Use more states for precise control.

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)"
		  "IN PROCESS(i)"
		  "POSTPONED(p)"
		  "|"
		  "DONE(d)")
	(sequence "|"
		  "CANCELED(c)")))

(setq org-todo-keyword-faces
      '(("TODO" . (:foreground "#B71C1C" :weight bold))
	("IN PROCESS" . (:foreground "#8BC34A" :weight bold))
	("POSTPONED" . (:foreground "#F57C00" :weight bold))
	("DONE" . (:foreground "#33691E" :weight bold))
	("CANCELED" . (:foreground "#757575" :weight bold))))
#+end_src

**** Capturing System

Capture entries via ~org-capture~.

#+begin_src emacs-lisp
(use-package org-capture
  :ensure nil
  :after org
  :config
  (add-to-list 'org-capture-templates
	       `("i" "inbox" entry
		 (file+headline ,zy/gtd-inbox-path "inbox")
		 "* TODO [#B] %U %i%?"
		 :empty-lines 1))
  (add-to-list 'org-capture-templates
	       `("s" "someday" entry
		 (file+headline ,zy/gtd-someday-path "someday")
		 "* TODO [#C] %U %i%?"
		 :empty-lines 1))
  (add-to-list 'org-capture-templates
	       `("g" "GTD" entry
		 (file+datetree ,zy/gtd-gtd-path)
		 "* TODO [#B] %U %i%?"
		 :empty-lines 1)))
#+end_src

**** Refile Mechanism

Use the ~org-refile~ mechanism to distribute inbox items.

#+begin_src emacs-lisp
(use-package org-refile
  :ensure nil
  :after org
  :config
  (add-to-list 'org-refile-targets `(,zy/gtd-gtd-path :maxlevel . 3))
  (add-to-list 'org-refile-targets `(,zy/gtd-someday-path :level . 1)))
#+end_src

**** Agenda

Agenda is the way to display all my GTD entries.

#+begin_src emacs-lisp
(use-package org-agenda
  :ensure nil
  :after org
  :general
  ("C-c a" 'org-agenda)
  :config
  (setq org-agenda-files `(,zy/gtd-inbox-path
			   ,zy/gtd-gtd-path
			   ,zy/gtd-someday-path)))
#+end_src

*** Language Server Protocol

Language server protocol is the future. It is well suited for Emacs, a free and
open source text editor.

#+begin_src emacs-lisp
(use-package lsp-mode
  :requires lsp-mode
  :config
  (setq lsp-keymap-prefix "C-c l"))

(use-package lsp-ui
  :after lsp-mode)

(use-package lsp-ivy
  :after (lsp-mode ivy))
#+end_src

~lsp-mode~ should be enabled for each mode individually.

**** UI

Settings for lsp-ui.

Remap =xref-find-{definitions,references}= (=M-.= and =M-?= by default).

#+begin_src emacs-lisp
(general-define-key
 :keymap 'lsp-ui-mode-map
 "M-." #'lsp-ui-peek-find-definitions
 "M-?" #'lsp-ui-peek-find-references)
#+end_src

*** Lorem Ipsum Generator

Use a package to generate dummy Latin text into a buffer.

#+begin_src emacs-lisp
(use-package lorem-ipsum)
#+end_src

Use ~lorem-ipsum-insert-paragraphs~, ~lorem-ipsum-insert-sentences~, and
~lorem-ipsum-insert-list~.

*** Org-Roam

Org-roam is a tool for network thought. I decided to try it on
<2021-03-15 Mon>.

**** Installation

Above all, install it, along with org-roam-ui, which visualize notes. It is
worth noticing that I upgrade org-roam from v1 to v2 at [2021-08-30 Mon].

#+begin_src emacs-lisp
(setq org-roam-v2-ack t)
(require 'org-roam)
(use-package org-roam
  :requires org-roam
  :config
  (setq org-roam-directory (concat zy/zybox-path "org-roam"))
  (unless (file-exists-p org-roam-directory)
    (make-directory org-roam-directory))
  (org-roam-setup))
#+end_src

**** Shortcuts

Define a series of shortcuts for org-roam. "z" for Zettelkasten.

#+begin_src emacs-lisp
(define-prefix-command 'zy/org-roam-map)
(general-define-key
 "C-c z" 'zy/org-roam-map)

(general-define-key
 :keymaps 'zy/org-roam-map
 "c" 'org-roam-capture
 "f" 'org-roam-node-find
 "i" 'org-roam-node-insert
 "t" 'org-roam-buffer-toggle)
#+end_src

**** UI with =org-roam-ui=

Org-Roam-UI, in place of Org-Roam-Server for v1, is a frontend for exploring and
interacting with org-roam notes for Org-Roam v2.

However, it's not yet on MELPA, so I added it as a submodule, and had to install
its dependencies manually.

#+begin_src emacs-lisp
(use-package org-roam-ui
  :load-path "site-lisp/org-roam-ui"
  :requires (websocket simple-httpd))
#+end_src

**** Exclude Org-Roam from Recentf

#+begin_src emacs-lisp
(use-package recentf
  :ensure nil
  :config
  (with-eval-after-load "org-roam"
    (add-to-list 'recentf-exclude
		 org-roam-directory)))
#+end_src

*** Quick Access

I want to reach several important files quickly with shortcuts.

#+begin_src emacs-lisp
(defvar zy/quick-access-choices nil
  "A list of quick access shortcuts, names and paths.")
(setq zy/quick-access-choices
      `((?e "Emacs Config" ,zy/emacs-config-file)
	(?z "Zybox" ,zy/zybox-path)
	(?p "Projects" ,zy/projects-path)
	(?s "Std-Proj" ,zy/std-proj-path)))

(defun zy/quick-access (arg)
  "`find-file' a quick access path if ARG is nil.

Prefix it with C-u to `find-file-other-window'. And prefix it with double C-u
to `file-file-other-frame'.

Quick access paths are defined in `zy/quick-access-choices'"
  (interactive "P")
  (let* ((find-file-function
	  (cond
	   ((equal arg '(4)) 'find-file-other-window)
	   ((equal arg '(16)) 'find-file-other-frame)
	   (t 'find-file)))
	 (choice
	  (read-multiple-choice
	   "Choose a quick access target."
	   zy/quick-access-choices))
	 (target
	  (nth 2 choice)))
    (funcall find-file-function target)))

(general-define-key "C-c o" #'zy/quick-access)
#+end_src
